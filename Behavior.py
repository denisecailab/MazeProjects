import os
import numpy as np
import pandas as pd
from matplotlib.animation import FFMpegWriter
from LickArduino import clean_Arduino_output
from util import read_eztrack, find_closest
import matplotlib.pyplot as plt
import cv2
from CircleTrack.utils import circle_sizes, cart2pol, grab_paths
import pickle as pkl

def make_tracking_video(vid_path, csv_path, output_fname='Tracking.avi',
                        start=0, stop=None, fps=30, Arduino_path=None):
    """
    Makes a video to visualize licking at water ports and position of the animal.

    :parameters
    ---
    video_fname: str
        Full path to the behavior video.

    csv_fname: str
        Full path to the csv file from EZTrack.

    output_fname: str
        Desired file name for output. It will be saved to the same folder
        as the data.

    start: int
        Frame to start on.

    stop: int or None
        Frame to stop on or if None, the end of the movie.

    fps: int
        Sampling rate of the behavior camera.

    Arduino_path:
        Full path to the Arduino output txt. If None, doesn't plot licking.

    """
    # Get behavior video.
    vid = cv2.VideoCapture(vid_path)
    if stop is None:
        stop = int(vid.get(7))  # 7 is the index for total frames.

    # Save data to the same folder.
    folder = os.path.split(vid_path)[0]
    output_path = os.path.join(folder, output_fname)

    # Get EZtrack data.
    if Arduino_path is not None:
        eztrack = sync_Arduino_outputs(Arduino_path, csv_path)[0]
        eztrack = clean_lick_detection(eztrack)
        port_colors = ['saddlebrown',
                       'red',
                       'orange',
                       'yellow',
                       'green',
                       'blue',
                       'darkviolet',
                       'gray']
    else:
        eztrack = read_eztrack(csv_path)
        port_colors = None

    # Make video.
    fig, ax = plt.subplots()
    writer = FFMpegWriter(fps=fps)
    with writer.saving(fig, output_path, 100):
        for frame_number in np.arange(start, stop):
            # Plot frame.
            vid.set(1, frame_number)
            ret, frame = vid.read()
            ax.imshow(frame)

            # Plot position.
            x = eztrack.at[frame_number, 'x']
            y = eztrack.at[frame_number, 'y']
            ax.scatter(x, y, marker='+', s=60, c='w')

            ax.text(0, 0, 'Frame: ' + str(frame_number) +
                    '   Time: ' + str(np.round(frame_number/30, 1)) + ' s')

            # Lick indicator.
            if Arduino_path is not None:
                licking_at_port = eztrack.at[frame_number, 'lick_port']
                if licking_at_port >= 0:
                    ax.scatter(x, y, s=200, marker='+',
                               c=port_colors[licking_at_port])

            ax.set_aspect('equal')
            plt.axis('off')

            writer.grab_frame()

            plt.cla()


def sync_Arduino_outputs(Arduino_fpath, eztrack_fpath, behav_cam=2):
    """
    This function is meant to be used in conjunction with the above
    functions and Miniscope software recordings. Miniscope software
    will save videos (behavior and imaging) in a timestamped folder.

    :param folder:
    :return:
    """
    # Read the txt file generated by Arduino.
    Arduino_data, offset = clean_Arduino_output(Arduino_fpath)

    # Read the position data generated by ezTrack.
    eztrack_data = read_eztrack(eztrack_fpath)
    eztrack_data['water'] = False
    eztrack_data['lick_port'] = int(-1)

    # Get timestamping information from DAQ output.
    folder = os.path.split(eztrack_fpath)[0]
    timestamp_fpath = os.path.join(folder, 'timestamp.dat')
    try:
        DAQ_data = pd.read_csv(timestamp_fpath, sep="\s+")
    except:
        raise Exception('DAQ timestamp.dat not found or corrupted.')

    # Only take the rows corresponding to the behavior camera.
    DAQ_data = DAQ_data[DAQ_data.camNum == behav_cam]

    # Find the frame number associated with the timestamp of a lick.
    sysClock = np.asarray(DAQ_data.sysClock)
    for i, row in Arduino_data.iterrows():
        closest_time = find_closest(sysClock, row.Timestamp - offset,
                                    sorted=True)[1]
        frame_num = DAQ_data.loc[DAQ_data.sysClock == closest_time]['frameNum']
        val = row.Data

        if val.isnumeric():
            eztrack_data.at[frame_num, 'lick_port'] = int(val)
        elif val == 'Water':
            eztrack_data.at[frame_num, 'water'] = True

    return eztrack_data, Arduino_data


def find_water_ports(eztrack_data):
    """
    Use the x and y extrema to locate water port locations. Requires that the
    maze be positioned so that a port is at the 12 o'clock position. Which port
    is not important -- the code can be modified for any orientation.

    :parameter
    ---
    eztrack_data: cleaned DataFrame from sync_Arduino_outputs()

    :return
    ---
    ports: DataFrame
        DataFrame with 'x' and 'y' columns corresponding to x and y positions of
        each water port.
    """
    (width, height, radius, center) = circle_sizes(eztrack_data.x, eztrack_data.y)
    theta = np.pi/4     # Angle in between each water port.

    # Determines orientation of the water ports.
    # List the port number of the port at 12 o'clock and count up.
    orientation = [7, 0, 1, 2, 3, 4, 5, 6]
    port_angles = [o * theta for o in orientation]

    # Calculate port locations.
    ports = {}
    ports['x'] = radius * np.cos(port_angles) + center[0]
    ports['y'] = radius * np.sin(port_angles) + center[1]
    ports = pd.DataFrame(ports)

    # Debugging purposes.
    # port_colors = ['saddlebrown',
    #                'red',
    #                'orange',
    #                'yellow',
    #                'green',
    #                'blue',
    #                'darkviolet',
    #                'gray']
    # plt.plot(eztrack_data.x, eztrack_data.y)
    # plt.scatter(center[0], center[1], c='r')
    # for color, (i, port) in zip(port_colors, ports.iterrows()):
    #     plt.scatter(port['x'], port['y'], c=color)
    # plt.axis('equal')

    return ports


def clean_lick_detection(eztrack_data, threshold=80):
    """
    Clean lick detection data by checking that the mouse is near the port during
    a detected lick.

    :parameters
    ---
    eztrack_data: cleaned DataFrame from sync_Arduino_outputs()

    threshold: float
        Distance threshold (in pixels) to be considered "near" the port.

    :return
    ---
    eztrack_data: cleaned DataFrame after eliminating false positives.
    """
    ports = find_water_ports(eztrack_data)

    lick_frames = eztrack_data[eztrack_data.lick_port > -1]
    for i, frame in lick_frames.iterrows():
        frame = frame.copy()
        port_num =  frame.lick_port
        frame_num = frame.frame

        distance = np.sqrt((frame.x - ports.at[port_num, 'x'])**2 +
                           (frame.y - ports.at[port_num, 'y'])**2)

        if distance > threshold:
            eztrack_data.at[frame_num, 'lick_port'] = -1

    return eztrack_data


def linearize_trajectory(eztrack_data, x=None, y=None):
    """
    Linearizes circular track trajectory.

    :parameter
    ---
    eztrack_data: output from read_eztrack()

    :returns
    ---
    angles: array
        Basically the linearized trajectory. Technically it is the
        polar coordinate with the center of the maze as the origin.

    radii: array
        Vector length of polar coordinate. Basically the distance from
        the center. Maybe useful for something.
    """
    # Get circle size.
    if x is None:
        x = eztrack_data.x
    if y is None:
        y = eztrack_data.y
    (width, height, radius, center) = circle_sizes(eztrack_data.x,
                                                   eztrack_data.y)

    # Convert to polar coordinates.
    angles, radii = cart2pol(x-center[0], y-center[1])

    # Shift everything so that 12 o'clock (pi/2) is 0.
    angles += np.pi/2
    angles = np.mod(angles, 2*np.pi)

    return angles, radii


def plot_licks(eztrack_data):
    """
    Plot points where mouse licks.

    :parameter
    ---
    eztrack_data: output from Preprocess

    :return
    ---
    fig, ax: Figure and Axes
        Contains the plots.
    """
    # Make sure licks have been retrieved.
    if 'lick_port' not in eztrack_data:
        raise KeyError('Run sync_Arduino_outputs and clean_lick_detection first.')
    else:
        licks = eztrack_data.lick_port
        licks[licks == -1] = np.nan

    # Linearize mouse's trajectory.
    lin_dist = linearize_trajectory(eztrack_data)[0]

    # Find the water ports and get their linearized location.
    ports = find_water_ports(eztrack_data)
    lin_ports = linearize_trajectory(eztrack_data, ports['x'], ports['y'])[0]

    # Make the array for plotting.
    licks = [lin_ports[port_id] if not np.isnan(port_id) else np.nan for port_id in licks]

    # Plot.
    fig, ax = plt.subplots()
    ax.plot(lin_dist)
    ax.plot(licks, marker='x', markersize=10)
    ax.invert_yaxis()
    ax.set_xlabel('Time (frames)')
    ax.set_ylabel('Linearized distance (radians)')

    return fig, ax


def find_rewarded_ports(eztrack_data):
    """
    Find which port numbers are rewarded by looking at the flag
    one timestamp before water delivery. Note that the mouse must
    lick at each rewarded port a handful of times for this to work.

    :parameter
    ---
    eztrack_data: output from Preprocess()

    :return
    ---
    ports: array
        Port numbers that were rewarded.
    """
    if 'water' not in eztrack_data:
        raise KeyError('Run sync_Arduino outputs and clean_lick_detection first.')

    # Get index one before water delivery (the lick that triggered it).
    one_before = np.where(eztrack_data.water)

    # Find unique port numbers.
    rewarded_ports = np.unique(eztrack_data.loc[one_before, 'lick_port'])

    return rewarded_ports[rewarded_ports > -1]


def get_trials(eztrack_data):


class Preprocess:
    def __init__(self, folder: str):
        """
        Preprocesses behavior data by specifying a session folder.

        :parameter
        ---
        folder: str
            Folder path to session.
        """
        self.folder = folder

        # Get the paths to relevant files.
        self.paths = grab_paths(self.folder)
        self.paths['PreprocessedBehavior'] = \
            os.path.join(self.paths['MiniscopeFolder'], 'Behavior.pkl')

        # Check if Preprocess has been ran already by attempting
        # to load a pkl file.
        try:
            with open(self.paths['PreprocessedBehavior'], 'rb') as file:
                previous = pkl.load(file)
            self.eztrack_data = previous.eztrack_data

        # If not, sync Arduino data.
        except:
            self.eztrack_data = sync_Arduino_outputs(self.paths['Arduino'],
                                                     self.paths['ezTrack'])[0]
            self.eztrack_data = clean_lick_detection(self.eztrack_data)


    def save(self, path=None, fname='Behavior.pkl'):
        """
        Save preprocessed data.

        path: str
            Folder path to save to. If None, default to session folder.

        fname: str
            File name to call the pkl file.

        """
        if path is None:
            fpath = self.paths['PreprocessedBehavior']
        else:
            fpath = os.path.join(path, fname)

        with open(fpath, 'wb') as file:
            pkl.dump(self, file)


if __name__ == '__main__':
    folder = r'D:\Projects\CircleTrack\Mouse1\12_20_2019'
    behav = Preprocess(folder)

    find_rewarded_ports(behav.eztrack_data)